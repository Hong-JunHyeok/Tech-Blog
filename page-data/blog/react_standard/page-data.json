{"componentChunkName":"component---src-template-post-page-jsx","path":"/blog/react_standard/","result":{"data":{"markdownRemark":{"html":"<h1>⚛️ 리액트의 기초</h1>\n<blockquote>\n<h3>⚠️ 이 글은 React.js 공식 자습서에 의존하고 있는 글입니다.</h3>\n</blockquote>\n<hr />\n<h1>목차</h1>\n<p>이번 목차는 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/48292190/116813790-88946900-ab90-11eb-9e42-46a285a0f2ea.png\" alt=\"image\"></p>\n<h1>목적</h1>\n<p>리액트 공식 사이트에서 TicTacToe가 예제로 나왔는데 이를 보고 이해를 하지 못하는 사람들도 많고 햇갈리는 부분이 있을수도 있기때문에 이를 보완하고자. 이 기초 파트를 준비했습니다.</p>\n<blockquote>\n<h3>⚠️ 이 글은 React.js 공식 자습서에 의존하고 있는 글입니다.</h3>\n</blockquote>\n<p>시작해보도록 하겠습니다.</p>\n<h1>JSX</h1>\n<h2>🤨 JSX 소개</h2>\n<p>먼저, 아래의 코드를 보도록 합시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code>\n        </deckgo-highlight-code>\n<p>위의 문법은 HTML도, 문자열도 아닙니다.</p>\n<p><strong>JavaScript를 확장한 문법인 JSX라고 합니다.</strong></p>\n<p>JSX는 JavaScript의 모든 기능이 포함되어 있습니다.</p>\n<p><strong>JSX는 엘리먼트(element)를 생성합니다.</strong></p>\n<p>React에서는 이벤트가 처리되는 방식, 시간에 따라 state가 변하는 방식, 화면에 표시하기 위해 데이터가 준비되는 방식 등 <strong>렌더링 로직이 본질적으로 다른 UI 로직과 연결된다는 사실을 받아들입니다.</strong></p>\n<p><img src=\"https://blog.kakaocdn.net/dn/bgsR0l/btqBSOXRul7/vqCF5iy4EpEpxY3qIulYCK/img.png\" alt=\"image\"></p>\n<p>JSX는 사실 리액트에서 <code>필수</code>로 요구되는 문법은 아닙니다. <a href=\"https://ko.reactjs.org/docs/react-without-jsx.html\">관련 링크</a></p>\n<p>대부분의 사람은 JavaScript 코드 안에서 UI 관련 작업을 할 때 시각적으로 더 도움이 된다고 생각합니다.</p>\n<p>이제 JSX를 사용하는 방법을 알아보도록 하겠습니다.\n예제를 보면 이해가 수월해질 겁니다.</p>\n<h2>JSX에 표현식 포함하기</h2>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const name = &quot;Josh Perez&quot;;\nconst element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;</code>\n        </deckgo-highlight-code>\n<p>JSX에 {}안에는 모든 JavaScript표현식을 넣을 수 있습니다.</p>\n<p>예를 들면 <code>2 + 2</code>나 <code>user.name</code>이나 <code>formatTime(time)</code>등이나 사용할 수 있는것이죠.</p>\n<h2>JSX도 표현식입니다</h2>\n<p>컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식됩니다.</p>\n<p>그러면 우리가 무슨작업을 할 수 있냐면,</p>\n<p>다음과 같은 작업을 수행할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function getGreeting(user) {\n  if (user) {\n    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;\n  }\n  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;\n}</code>\n        </deckgo-highlight-code>\n<p>지금 집중해서 볼 부분은 if문입니다. 이러한 표현식이 가능한것이죠.</p>\n<p><strong>JSX를 if 구문 및 for loop 안에 사용하고, 변수에 할당하고, 인자로서 받아들이고, 함수로부터 반환할 수 있습니다.</strong></p>\n<h2>JSX 속성 정의</h2>\n<p>속성에 따옴표를 이용해 문자열 리터럴을 정의할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</code>\n        </deckgo-highlight-code>\n<p>또한 JavaScript표현식도 넣을 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<h2>⚠️주의할 점</h2>\n<p>어트리뷰트에 JavaScript 표현식을 삽입할 때 중괄호 주변에 따옴표를 입력하지 마세요. 따옴표(문자열 값에 사용) 또는 중괄호(표현식에 사용) 중 하나만 사용하고, 동일한 어트리뷰트에 두 가지를 동시에 사용하면 안 됩니다.</p>\n</blockquote>\n<p>JSX는 HTML보다 JavaScript에 더 가깝기때문에 <strong>React DOM은 HTML 어트리뷰트 이름 대신 camelCase 프로퍼티 명명 규칙을 사용합니다.</strong></p>\n<p>대표적인 예로는 <code>class</code>가 아니라 <code>className</code>입니다.</p>\n<h2>JSX로 자식 정의</h2>\n<p>태그가 비어있다면 XML처럼 /> 를 이용해 바로 닫아주어야 합니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = &lt;img src={user.avatarUrl} /&gt;;</code>\n        </deckgo-highlight-code>\n<p>JSX태그는 자식을 표함할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = (\n  &lt;div&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;h2&gt;Good to see you here.&lt;/h2&gt;\n  &lt;/div&gt;\n);</code>\n        </deckgo-highlight-code>\n<p><strong>JSX태그는 반드시 최상위 태그가 닫혀있어여합니다.</strong></p>\n<h2>JSX는 주입 공격을 방지합니다</h2>\n<p>XSS인 사이트 간 스크립팅 공격을 방지할 수 있습니다. 기본적으로 React DOM은 JSX에 삽입된 모든 값을 렌더링하기 전에 이스케이프 하므로 가능한 일이죠. <strong>애플리케이션에서 명시적으로 작성되지 않은 내용은 주입되지 않습니다. 모든 항목은 렌더링 되기 전에 문자열로 변환됩니다.</strong></p>\n<p><img src=\"https://portswigger.net/web-security/images/cross-site-scripting.svg\" alt=\"image\"></p>\n<h2>JSX는 객체를 표현합니다.</h2>\n<p>Babel은 JSX를 React.createElement() 호출로 컴파일합니다.</p>\n<p>코드를 보고 알아보도록 하죠.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = &lt;h1 className=&quot;greeting&quot;&gt;Hello, world!&lt;/h1&gt;;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = React.createElement(\n  &quot;h1&quot;,\n  { className: &quot;greeting&quot; },\n  &quot;Hello, world!&quot;\n);</code>\n        </deckgo-highlight-code>\n<p><strong>이제 createElement가 무엇을 만드는지 보도록 할까요?</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">// 주의: 다음 구조는 단순화되었습니다\nconst element = {\n  type: &quot;h1&quot;,\n  props: {\n    className: &quot;greeting&quot;,\n    children: &quot;Hello, world!&quot;,\n  },\n};</code>\n        </deckgo-highlight-code>\n<p>위와 같은 형식으로 만들어줍니다. 즉, 객체를 표현합니다.</p>\n<blockquote>\n<p>이러한 객체를 “React 엘리먼트”라고 하며, 화면에서 보고 싶은 것을 나타내는 표현이라 생각하면 됩니다. React는 이 객체를 읽어서, DOM을 구성하고 최신 상태로 유지하는 데 사용합니다.</p>\n</blockquote>\n<h1>엘리먼트 랜더링</h1>\n<blockquote>\n<p>\"엘리먼트는 React 앱의 가장 작은 단위입니다.\" - 리액트 공식문서</p>\n</blockquote>\n<p>이번에 알아볼것은 엘리먼트의 랜더링입니다.</p>\n<p>엘리먼트는 <strong>화면에 표시할 내용</strong>을 기술합니다.</p>\n<blockquote>\n<p>이쯤되면 <strong>컴포넌트</strong>와 <strong>엘리먼트</strong>가 햇갈릴 수 있습니다.\n엘리먼트는 컴포넌트의 “구성 요소”입니다. 자세한 설명은 다음장에 계속 설명하겠습니다.</p>\n</blockquote>\n<h2>DOM에 엘리먼트 렌더링하기</h2>\n<p>HTML파일 어딘가에 <div>가 있다고 생각해봅시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<p>이 안에 들어가는 모든 엘리먼트를 React DOM에서 관리하기 때문에 이것을 “루트(root)” DOM 노드라고 부릅니다.</p>\n<p><strong>React로 구현된 애플리케이션은 일반적으로 하나의 루트 DOM 노드가 있습니다.</strong> React를 기존 앱에 통합하려는 경우 원하는 만큼 많은 수의 독립된 루트 DOM 노드가 있을 수 있습니다.</p>\n<p><strong>React 엘리먼트를 루트 DOM 노드에 렌더링하려면 둘 다 ReactDOM.render()로 전달하면 됩니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;\nReactDOM.render(element, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<h2>렌더링 된 엘리먼트 업데이트하기</h2>\n<p>React 엘리먼트는 <strong>불변객체</strong>입니다.</p>\n<p><strong>불변객체</strong>... 이부분이 중요한 부분입니다.</p>\n<p>엘리먼트를 생성한 이후에는 해당 엘리먼트의 자식이나 속성을 변경할 수 없습니다. 엘리먼트는 영화에서 하나의 프레임과 같이 특정 시점의 UI를 보여줍니다.</p>\n<p><strong>UI를 업데이트하는 유일한 방법은 새로운 엘리먼트를 생성하고 이를 ReactDOM.render()로 전달하는 것입니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function tick() {\n  const element = (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n  ReactDOM.render(element, document.getElementById(&quot;root&quot;));\n}\n\nsetInterval(tick, 1000);</code>\n        </deckgo-highlight-code>\n<p>위의 함수는 1초마다 새로운 리액트 DOM을 랜더링합니다.</p>\n<blockquote>\n<p>실제로 대부분의 React 앱은 ReactDOM.render()를 한 번만 호출합니다.</p>\n</blockquote>\n<h2>변경된 부분만 업데이트하기</h2>\n<blockquote>\n<p>React DOM은 해당 엘리먼트와 그 자식 엘리먼트를 이전의 엘리먼트와 비교하고 DOM을 원하는 상태로 만드는데 필요한 경우에만 DOM을 업데이트합니다.</p>\n</blockquote>\n<p>이 말이 무슨말이냐면 \"변경된 부분만 업데이트\"하는 것입니다.</p>\n<p><img src=\"https://ko.reactjs.org/c158617ed7cc0eac8f58330e49e48224/granular-dom-updates.gif\" alt=\"gif\"></p>\n<p>매초 전체 UI를 다시 그리도록 엘리먼트를 만들었지만 React DOM은 내용이 변경된 텍스트 노드만 업데이트했습니다.</p>\n<h1>Components and Props</h1>\n<p>컴포넌트의 개념을 설명해보도록 하겠습니다.</p>\n<p><strong>컴포넌트는 JavaScript 함수와 유사합니다. “props”라고 하는 임의의 입력을 받은 후, 화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환합니다.</strong></p>\n<h2>함수 컴포넌트와 클래스 컴포넌트</h2>\n<p>컴포넌트를 정의하는 가장 간단한 방법은 JavaScript함수를 사용하는 것입니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function SimpleComponent(props) {\n  return &lt;h1&gt;Hello Function Component, I am {props.name}&lt;/h1&gt;;\n}</code>\n        </deckgo-highlight-code>\n<p>이 함수는 데이터를 가진 props (props는 속성을 나타내는 데이터입니다)라는 객체 인자를 받은 후, React엘리먼트를 반환합니다.</p>\n<p><strong>이것이 함수형 컴포넌트입니다.</strong></p>\n<p>ES6 Class문법을 사용하여 클래스형 컴포넌트도 정의할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class Welcome extends React.Component {\n  render() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>Class형에는 몇 가지 추가기능이 있습니다.\n<strong>함수 컴포넌트와 클래스 컴포넌트 둘 다 몇 가지 추가 기능이 있으며</strong> 이에 대해서는 다음에 자세히 설명하겠습니다.</p>\n<h1>컴포넌트 렌더링</h1>\n<p>React 엘리먼트는 사용자 정의 컴포넌트로 나타낼 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</code>\n        </deckgo-highlight-code>\n<p><code>name=\"Sara\"</code>라고 된 부분이 있죠? 그 부분을 우리가 <strong>props를 전달한다</strong> 라고 합니다.</p>\n<p>즉, props를 전달함으로서 다음과 같은 로직이 가능한것이죠.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Welcome(props) {\n  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;\n}\n\nconst element = &lt;Welcome name=&quot;Sara&quot; /&gt;;\nReactDOM.render(element, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<h1>컴포넌트 합성</h1>\n<p>컴포넌트는 자신의 출력에 다른 컴포넌트를 참조할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Welcome(props) {\n  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;Welcome name=&quot;Sara&quot; /&gt;\n      &lt;Welcome name=&quot;Cahal&quot; /&gt;\n      &lt;Welcome name=&quot;Edite&quot; /&gt;\n    &lt;/div&gt;\n  );\n}\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>React 앱에서는 버튼, 폼, 다이얼로그, 화면 등의 모든 것들이 흔히 컴포넌트로 표현됩니다.</p>\n<h1>컴포넌트 추출</h1>\n<p>컴포넌트를 추출하는 과정은 컴포넌트를 여러 개의 작은 컴포넌트로 나누는 과정을 의미합니다.</p>\n<p>이 과정을 과감히 해버리세요! 다음 코드를 봅시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Comment(props) {\n  return (\n    &lt;div className=&quot;Comment&quot;&gt;\n      &lt;div className=&quot;UserInfo&quot;&gt;\n        &lt;img\n          className=&quot;Avatar&quot;\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        /&gt;\n        &lt;div className=&quot;UserInfo-name&quot;&gt;{props.author.name}&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div className=&quot;Comment-text&quot;&gt;{props.text}&lt;/div&gt;\n      &lt;div className=&quot;Comment-date&quot;&gt;{formatDate(props.date)}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>음... 이게 React를 쓰는건지 HTML을 쓰는건지 잘 모르시겠죠?</p>\n<p>그래서 컴포넌트를 추출하는 과정을 통해 좀 더 직관적인 코드로 변경해보겠습니다.</p>\n<p>img태그부터 추출해보겠습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Avatar(props) {\n  return (\n    &lt;img className=&quot;Avatar&quot; src={props.user.avatarUrl} alt={props.user.name} /&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>그러면 Comment코드상에선,</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Comment(props) {\n  return (\n    &lt;div className=&quot;Comment&quot;&gt;\n      &lt;div className=&quot;UserInfo&quot;&gt;\n        &lt;Avatar user={props.author} /&gt;\n        &lt;div className=&quot;UserInfo-name&quot;&gt;{props.author.name}&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div className=&quot;Comment-text&quot;&gt;{props.text}&lt;/div&gt;\n      &lt;div className=&quot;Comment-date&quot;&gt;{formatDate(props.date)}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 치환될 수 있겠죠.</p>\n<p>그 다음 UserInfo컴포넌트도 만들어 보겠습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function UserInfo(props) {\n  return (\n    &lt;div className=&quot;UserInfo&quot;&gt;\n      &lt;Avatar user={props.user} /&gt;\n      &lt;div className=&quot;UserInfo-name&quot;&gt;{props.user.name}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이제 Comment가 더욱 단순해질 수 있겠죠?</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Comment(props) {\n  return (\n    &lt;div className=&quot;Comment&quot;&gt;\n      &lt;UserInfo user={props.author} /&gt;\n      &lt;div className=&quot;Comment-text&quot;&gt;{props.text}&lt;/div&gt;\n      &lt;div className=&quot;Comment-date&quot;&gt;{formatDate(props.date)}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이 작업이 굉장히 귀찮고 지루할 수 있습니다. 하지만 재사용 가능한 컴포넌트를 만들어 놓는 것은 더 큰 앱에서 작업할 때 두각을 나타냅니다.</p>\n<p><strong>UI 일부가 여러 번 사용되거나 (Button, Panel, Avatar), UI 일부가 자체적으로 복잡한 (App, FeedStory, Comment) 경우에는 별도의 컴포넌트로 만드는 게 좋습니다.</strong></p>\n<p><img src=\"https://media.vlpt.us/images/devgosunman/post/f0f69596-9dc9-4533-ba90-e12fd55a8c62/react%20state.jpg\" alt=\"image\"></p>\n<h1>props는 읽기 전용입니다.</h1>\n<p>무슨 말인지 한번 볼까요?</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function sum(a, b) {\n  return a + b;\n}</code>\n        </deckgo-highlight-code>\n<p>위의 함수는 <strong>순수 함수</strong>라고 합니다.</p>\n<p>순수 함수에 대해서는 <a href=\"https://velog.io/@chdb57/%E3%85%87%E3%85%87%E3%85%87%E3%85%87%E3%85%87%E3%85%87%E3%85%87%E3%85%87\">여기</a>를 참조해보시길 바랍니다.</p>\n<p><strong>모든 React 컴포넌트는 자신의 props를 다룰 때 반드시 순수 함수처럼 동작해야 합니다.</strong></p>\n<p>애플리케이션 UI는 동적이며 시간에 따라 변합니다. 그래서 위 규칙을 위반하지 않고 사용자 액션, 네트워크 응답 및 다른 요소에 대한 응답으로 시간에 따라 자신의 출력값을 변경할 수 있는 방법은 <code>State</code>입니다.</p>\n<p>이제 자세히 한번 알아보도록 할까요?</p>\n<p><img src=\"https://blog.kakaocdn.net/dn/b7Ing6/btqDrkNbvBs/Mi1pUyMUSRYYLmE6zvjAG0/img.png\" alt=\"image\"></p>\n<h1>State and Lifecycle</h1>\n<p>이전에 째깍거리는 시계를 랜더링 한거 기억나시죠? 출력값을 변경하기 위해서 새로 엘리먼트를 랜더링하는 작업을 해주었습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">ReactDOM.render();</code>\n        </deckgo-highlight-code>\n<p>일단 <code>Clock</code>이라는 컴포넌트를 만들어서 캡슐화를 진행해줍시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Clock(props) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(&lt;Clock date={new Date()} /&gt;, document.getElementById(&quot;root&quot;));\n}\n\nsetInterval(tick, 1000);</code>\n        </deckgo-highlight-code>\n<p>이렇게 진행하면 되겠죠?</p>\n<p>하지만 우리가 구현하고 싶은건</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">ReactDOM.render(&lt;Clock /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>딱 이코드 한번만 실행하고 싶습니다.</p>\n<p>이럴때 <code>state</code>를 사용해야 할 차례입니다.</p>\n<p><strong>State는 props와 유사하지만, 비공개이며 컴포넌트에 의해 완전히 제어됩니다.</strong></p>\n<h1>함수에서 클래스로 변환하기</h1>\n<p>state를 사용할려면 class형 컴포넌트를 사용해야 합니다.function형 컴포넌트에는 state를 사용할 수 없습니다. (React hooks를 쓰면 그게 가능해집니다.)</p>\n<p>다음 코드를 한번 살펴볼까요?</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class Clock extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nfunction tick() {\n  ReactDOM.render(&lt;Clock date={new Date()} /&gt;, document.getElementById(&quot;root&quot;));\n}\n\nsetInterval(tick, 1000);</code>\n        </deckgo-highlight-code>\n<p>이러면 함수형 컴포넌트를 클래스형 컴포넌트로 변환이 완료되었습니다.</p>\n<h1>클래스에 로컬 State 추가하기</h1>\n<p>class형 컴포넌트에 constructor를 정의해 주신다음에 다음과 같은 코드를 작성해주세요.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }</code>\n        </deckgo-highlight-code>\n<p>이 과정이 state를 선언하는 과정입니다.\nsuper(props)이 부분은 모든 class형 컴포넌트는 super(props)를 해주어야 합니다. (상속되어지는 관계이기 때문이죠)</p>\n<p>그 다음 this.state = {...} 이 부분이 state를 선언하는 부분입니다.</p>\n<p>date라는 속성에 new Date()를 하게 됨으로써 현제 시간을 data라는 state에 담게 되는것이죠.</p>\n<p><strong>최종 코드는 다음과 같습니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { date: new Date() };\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;Clock /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>하지만 실행해보면 안움직이죠?</p>\n<p>당연합니다! <strong>왜냐하면 매초 스스로 움직이라는 코드를 작성하지 않았으니까요!</strong></p>\n<p>한번 해보도록 하겠습니다.</p>\n<h1>생명주기 메서드를 클래스에 추가하기</h1>\n<p>Clock이 처음 DOM에 랜더링 될때마다 타이머를 설정할려고 합니다.\n또한 DOM이 삭제될때마다 타이머를 해제할려고 합니다.</p>\n<p>여기, 좋은 기능이 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">  componentDidMount() {\n  }\n\n  componentWillUnmount() {\n  }</code>\n        </deckgo-highlight-code>\n<p>이 기능을 사용하면 쉽게 랜더링 될 때, 삭제될 때를 확보할 수 있습니다.</p>\n<p>이러한 메서드들을 <strong>생명주기 메서드라고 합니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { date: new Date() };\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(() =&gt; this.tick(), 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date(),\n    });\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;\n        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;Clock /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>다음과 같이 작성해주세요.</p>\n<p>코드가 이해가지 않는 분들을 위한 설명타임이 있겠습니다.</p>\n<p><code>componentDidMount</code>는 컴포넌트가 랜더링 될 시기를 의미합니다.\n그러면</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">componentDidMount() {\n    this.timerID = setInterval(() =&gt; this.tick(), 1000);\n  }</code>\n        </deckgo-highlight-code>\n<p>다음과 같은 코드는 <strong>컴포넌트가 마운트 될 때 매초 tick이라는 함수를 실행한다는 의미입니다.</strong></p>\n<p><code>componentWillUnmount</code>는 컴포넌트가 삭제될 시기를 의미합니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">componentWillUnmount() {\n    clearInterval(this.timerID);\n  }</code>\n        </deckgo-highlight-code>\n<p>다음과 같은 코드는 interval된 타이머 함수를 컴포넌트가 삭제될 때 제거하겠다는 의미입니다.</p>\n<h1>State 업데이트는 비동기적일 수도 있습니다.</h1>\n<p>이 부분에서 state사용에 오류가 나는 경우가 많이 있습니다.</p>\n<p>this.props와 this.state가 비동기적으로 업데이트될 수 있기 때문에 다음 state를 계산할 때 해당 값에 의존해서는 안 됩니다.</p>\n<p>예를 한번 들어볼까요?</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});</code>\n        </deckgo-highlight-code>\n<p>이 업데이트는 실패할 수 있습니다.</p>\n<p>이를 수정하기 위해 객체보다는 함수를 인자로 사용하는 다른 형태의 setState()를 사용합니다. 그 함수는 이전 state를 첫 번째 인자로 받아들일 것이고, 업데이트가 적용된 시점의 props를 두 번째 인자로 받아들일 것입니다.</p>\n<p>즉, 다음 형식으로 작성하면 됩니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">// Correct\nthis.setState((state, props) =&gt; ({\n  counter: state.counter + props.increment,\n}));</code>\n        </deckgo-highlight-code>\n<p>이전 state와 업데이트가 적용된 props를 받고 진행을 할겁니다.</p>\n<blockquote>\n<p>물론 화살표 함수 말고 그냥 function키워드 함수도 가능합니다.</p>\n</blockquote>\n<p><img src=\"https://media.vlpt.us/images/daybreak/post/4dfb762a-30f3-48ed-a380-4260f8c7e39f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-07-09%2016.39.35.png\" alt=\"image\"></p>\n<p>이 부분 정확히 짚고 넘어가주세요!</p>\n<h1>State 업데이트는 병합됩니다</h1>\n<p><code>setState()</code>를 호출할 때 React는 제공한 객체를 현재 state로 병합합니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">  constructor(props) {\n    super(props);\n    this.state = {\n      posts: [],\n      comments: []\n    };\n  }</code>\n        </deckgo-highlight-code>\n<p>다양한 독립적인 변수를 선언할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">  componentDidMount() {\n    fetchPosts().then(response =&gt; {\n      this.setState({\n        posts: response.posts\n      });\n    });\n\n    fetchComments().then(response =&gt; {\n      this.setState({\n        comments: response.comments\n      });\n    });\n  }</code>\n        </deckgo-highlight-code>\n<p><strong>this.setState({comments})는 this.state.posts에 영향을 주진 않지만 this.state.comments는 완전히 대체됩니다.</strong></p>\n<h1>데이터는 아래로 흐릅니다.</h1>\n<p>컴포넌트는 자신의 state를 자식 컴포넌트에 props로 전달할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;FormattedDate date={this.state.date} /&gt;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>FormattedDate 컴포넌트는 date를 자신의 props로 받을 것이고 이것이 Clock의 state로부터 왔는지, Clock의 props에서 왔는지, 수동으로 입력한 것인지 알지 못합니다.</p>\n</blockquote>\n<p><strong>트리구조가 props들의 폭포라고 상상하면 각 컴포넌트의 state는 임의의 점에서 만나지만 동시에 아래로 흐르는 부가적인 수원(water source)이라고 할 수 있습니다.</strong></p>\n<h1>이벤트 처리하기 🎪</h1>\n<p>React에서 이벤트를 처리하는 방식은 DOM엘리먼트에서 이벤트를 처리하는 방식과 거의 동일합니다.</p>\n<p>단, 문법적 차이가 있습니다.</p>\n<ul>\n<li>React의 이벤트는 소문자 대신 캐멀 케이스(camelCase)를 사용합니다.</li>\n<li>JSX를 사용하여 문자열이 아닌 함수로 이벤트 핸들러를 전달합니다.</li>\n</ul>\n<p>HTML에서 이벤트를 처리하는 방법은 다음과 같습니다.</p>\n<deckgo-highlight-code html  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;button onclick=&quot;activateLasers()&quot;&gt;Activate Lasers&lt;/button&gt;</code>\n        </deckgo-highlight-code>\n<p>React에서는 조금 다른방식으로 처리합니다.</p>\n<deckgo-highlight-code jsx  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;button onClick={activateLasers}&gt;Activate Lasers&lt;/button&gt;</code>\n        </deckgo-highlight-code>\n<p>또 다른 차이점으로, React에서는 false를 반환해도 기본 동작을 방지할 수 없습니다. 반드시 preventDefault를 명시적으로 호출해야 합니다.</p>\n<p>이게 무슨 말인지 이해가 되지 않는다면 다음의 코드를 살펴보세요.</p>\n<p>HTML에서 a태그의 새 페이지를 여는 동작을 방지하기 위해서 다음과 같이 씁니다.</p>\n<deckgo-highlight-code html  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;a href=&quot;#&quot; onclick=&quot;console.log(&#39;The link was clicked.&#39;); return false&quot;&gt;\n  Click me\n&lt;/a&gt;</code>\n        </deckgo-highlight-code>\n<p>리액트에서는 return false를 한다고 해결되지 않습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log(&quot;The link was clicked.&quot;);\n  }\n\n  return (\n    &lt;a href=&quot;#&quot; onClick={handleClick}&gt;\n      Click me\n    &lt;/a&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p><code>preventDefault()</code>라는 함수를 사용해서 <strong>React 이벤트는 브라우저 고유 이벤트와 정확히 동일하게 동작하지는 않습니다.</strong></p>\n<p>또한 React에서 <code>addEventListener</code>를 사용할 필요가 없습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isToggleOn: true };\n\n    // 콜백에서 `this`가 작동하려면 아래와 같이 바인딩 해주어야 합니다.\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState((state) =&gt; ({\n      isToggleOn: !state.isToggleOn,\n    }));\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        {this.state.isToggleOn ? &quot;ON&quot; : &quot;OFF&quot;}\n      &lt;/button&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;Toggle /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>이렇게 작성하면 정삭적으로 onClick이 리스닝 됩니다.</p>\n<p>하지만 코드를 보면 조금 햇갈리는 부분이 있을겁니다.</p>\n<p>바로 <code>.bind</code>부분인데요.</p>\n<p>JSX콜백 안에서 this의 의미를 생각해 보아야합니다.</p>\n<p><strong>JavaScript에서 클래스 메서드는 기본적으로 바인딩되어 있지 않습니다</strong></p>\n<h1>이벤트 핸들러에 인자 전달하기</h1>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;\n&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>화살표 함수를 사용하면 event를 명시적으로 전달해 주어야하고,</li>\n<li>bind를 하면 자동으로 event가 전달됩니다.</li>\n</ul>\n<h1>조건부 렌더링</h1>\n<p>React에서는 원하는 동작을 캡슐화하는 컴포넌트를 만들 수 있습니다.</p>\n<p>React에서 조건부 렌더링은 JavaScript에서의 조건 처리와 같이 동작합니다</p>\n<p>한번 보도록 할까요?</p>\n<p>로그인을 할 때 로그인 상태에 맞는 컴포넌트를 렌더링 해주어야 합니다.</p>\n<p>예를 들어서 밑에 두 컴포넌트가 있다고 해봅시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function UserGreeting(props) {\n  return &lt;h1&gt;Welcome back!&lt;/h1&gt;;\n}\n\nfunction GuestGreeting(props) {\n  return &lt;h1&gt;Please sign up.&lt;/h1&gt;;\n}</code>\n        </deckgo-highlight-code>\n<p>그러면 로그인이 되었을때와 안되었을때를 나누어서 조건부 렌더링을 해야하죠?</p>\n<p>이제 그 방법을 살펴보도록 하겠습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return &lt;UserGreeting /&gt;;\n  }\n  return &lt;GuestGreeting /&gt;;\n}\n\nReactDOM.render(\n  // Try changing to isLoggedIn={true}:\n  &lt;Greeting isLoggedIn={false} /&gt;,\n  document.getElementById(&quot;root&quot;)\n);</code>\n        </deckgo-highlight-code>\n<p>props로 전달받은 isLoggedIn이라는 상태를 기반으로 <code>if</code>으로 조건부 렌더링을 하는 부분이 보이죠?</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">if (isLoggedIn) {\n  return &lt;UserGreeting /&gt;;\n}\nreturn &lt;GuestGreeting /&gt;;</code>\n        </deckgo-highlight-code>\n<p>이부분을 유심히 봐주세요.</p>\n<p><strong>이 예시는 isLoggedIn prop에 따라서 다른 인사말을 렌더링 합니다.</strong></p>\n<p>컴포넌트 단위 말고도 엘리먼트 단위로도 구현할 수 있습니다.</p>\n<p>다음과 같은 컴포넌트가 있다고 생각해봅시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function LoginButton(props) {\n  return &lt;button onClick={props.onClick}&gt;Login&lt;/button&gt;;\n}\n\nfunction LogoutButton(props) {\n  return &lt;button onClick={props.onClick}&gt;Logout&lt;/button&gt;;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = { isLoggedIn: false };\n  }\n\n  handleLoginClick() {\n    this.setState({ isLoggedIn: true });\n  }\n\n  handleLogoutClick() {\n    this.setState({ isLoggedIn: false });\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n    let button;\n    if (isLoggedIn) {\n      button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;\n    } else {\n      button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;\n    }\n\n    return (\n      &lt;div&gt;\n        &lt;Greeting isLoggedIn={isLoggedIn} /&gt;\n        {button}\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;LoginControl /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>이제 만들었던 컴포넌트를 이렇게 렌더링할 수 있습니다.</p>\n<p>여기서 if문을 사용해서 조건부 렌더링 해도 되지만, 다양한 방법을 사용해서 축약형으로 사용할 수 있습니다.</p>\n<h1>논리 &#x26;&#x26; 연산자로 If를 인라인으로 표현하기</h1>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello!&lt;/h1&gt;\n      {unreadMessages.length &gt; 0 &amp;&amp; (\n        &lt;h2&gt;You have {unreadMessages.length} unread messages.&lt;/h2&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n\nconst messages = [&quot;React&quot;, &quot;Re: React&quot;, &quot;Re:Re: React&quot;];\nReactDOM.render(\n  &lt;Mailbox unreadMessages={messages} /&gt;,\n  document.getElementById(&quot;root&quot;)\n);</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>JavaScript에서 true &#x26;&#x26; expression은 항상 expression으로 평가되고 false &#x26;&#x26; expression은 항상 false로 평가됩니다.</p>\n</blockquote>\n<p>따라서 &#x26;&#x26; 뒤의 엘리먼트는 조건이 true일때 출력이 됩니다. 조건이 false라면 React는 무시합니다.</p>\n<h1>조건부 연산자로 If-Else구문 인라인으로 표현하기</h1>\n<p>흔히 아는 삼항연산자를 사용해서 이를 더 축약할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">render() {\n  const isLoggedIn = this.state.isLoggedIn;\n  return (\n    &lt;div&gt;\n      The user is &lt;b&gt;{isLoggedIn ? &#39;currently&#39; : &#39;not&#39;}&lt;/b&gt; logged in.\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이는 간단한 예시이지만, 나중에 조건이 많아지면 이 방법이 복잡할 수 있습니다.</p>\n<p><strong>JavaScript와 마찬가지로, 가독성이 좋다고 생각하는 방식을 선택하면 됩니다. 또한 조건이 너무 복잡하다면 컴포넌트를 분리하기 좋을 때 일 수도 있다는 것을 기억하세요.</strong></p>\n<h1>컴포넌트가 렌더링하는 것을 막기</h1>\n<p>저는 무슨 프로그램이는 최적화가 가장 중요하다고 생각합니다.</p>\n<p>이 부분은 최적화와 관련된 부분이므로 집중해서 공부해보겠습니다.</p>\n<p>아래의 예시에서는 <WarningBanner />가 warn prop의 값에 의해서 렌더링됩니다. prop이 false라면 컴포넌트는 렌더링하지 않게 됩니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function WarningBanner(props) {\n  if (!props.warn) {\n    return null;\n  }\n\n  return &lt;div className=&quot;warning&quot;&gt;Warning!&lt;/div&gt;;\n}\n\nclass Page extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { showWarning: true };\n    this.handleToggleClick = this.handleToggleClick.bind(this);\n  }\n\n  handleToggleClick() {\n    this.setState((state) =&gt; ({\n      showWarning: !state.showWarning,\n    }));\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;WarningBanner warn={this.state.showWarning} /&gt;\n        &lt;button onClick={this.handleToggleClick}&gt;\n          {this.state.showWarning ? &quot;Hide&quot; : &quot;Show&quot;}\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;Page /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>컴포넌트의 render 메서드로부터 null을 반환하는 것은 생명주기 메서드 호출에 영향을 주지 않습니다. 그 예로 componentDidUpdate는 계속해서 호출되게 됩니다.</p>\n<h1>리스트와 Key</h1>\n<p>먼저 JavaScript에서 리스트를 어떻게 변환하는지 살펴봅시다.</p>\n<p>TicTacToe를 구현하면서 key와 리스트 관련해서 이슈가 있었던 적이있죠?</p>\n<p>이번 챕터에서는 그걸 더 자세히 알아볼려고 해요.</p>\n<p>리액트에서 엘리먼트 리스트를 만드는 방법은 다음과 유사합니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map((number) =&gt; number * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]</code>\n        </deckgo-highlight-code>\n<ul>\n<li>여러개의 컴포넌트 렌더링하기</li>\n</ul>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;);</code>\n        </deckgo-highlight-code>\n<p>이러면 listItems는 다음과 같은 모습을 하고있을 겁니다.</p>\n<deckgo-highlight-code html  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;li&gt;1&lt;/li&gt;\n&lt;li&gt;2&lt;/li&gt;\n&lt;li&gt;3&lt;/li&gt;\n&lt;li&gt;4&lt;/li&gt;\n&lt;li&gt;5&lt;/li&gt;</code>\n        </deckgo-highlight-code>\n<p>간단하죠?</p>\n<p><strong>일반적으로 컴포넌트 안에서 리스트를 렌더링합니다.</strong></p>\n<p>다음과 같이 작성합니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;);\n  return &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById(&quot;root&quot;)\n);</code>\n        </deckgo-highlight-code>\n<p>자, 실행해보세요.</p>\n<p>오류가 뜨나요?</p>\n<p>코드를 위의 코드 그대로 쓴 게 맞다면, 오류뜨는게 정상입니다.\n<img src=\"https://user-images.githubusercontent.com/48292190/116847416-6ef13100-ac25-11eb-9a79-ae3cd0c6873a.png\" alt=\"image\"></p>\n<p><strong>리스트의 각 항목에 key를 넣어야 한다는 경고가 표시됩니다.</strong></p>\n<p>“key”는 엘리먼트 리스트를 만들 때 포함해야 하는 특수한 문자열 어트리뷰트입니다.</p>\n<p>key의 역할에 대해서는 다음에 더욱 자세히 설명해보죠.</p>\n<p>지금은 오류부터 해결해 보자구요.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt; &lt;li key={number}&gt;{number}&lt;/li&gt;);\n  return &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById(&quot;root&quot;)\n);</code>\n        </deckgo-highlight-code>\n<p>어때요 오류가 잘 없어졌나요?</p>\n<h1>key</h1>\n<p>이제 key가 하는 역할을 좀 더 자세히 알아보도록 하겠습니다.</p>\n<p>key는 일종의 식별하기 위한 속성입니다.</p>\n<p>어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다.</p>\n<p>Key를 선택하는 가장 좋은 방법은 리스트의 다른 항목들 사이에서 해당 항목을 고유하게 식별할 수 있는 문자열을 사용하는 것입니다. 대부분의 경우 데이터의 ID를 key로 사용합니다.</p>\n<p><strong>정말 만약에 데이터에 id항목이 없다면 최후의 수단으로 index를 사용할 수 있습니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const todoItems = todos.map((todo, index) =&gt; (\n  // Only do this if items have no stable IDs\n  &lt;li key={index}&gt;{todo.text}&lt;/li&gt;\n));</code>\n        </deckgo-highlight-code>\n<p>권장하는 방법은 아니며, 이로 인해 성능이 저하되거나 컴포넌트의 state와 관련된 문제가 발생할 수 있습니다.</p>\n<p><strong>만약 리스트 항목에 명시적으로 key를 지정하지 않으면 React는 기본적으로 인덱스를 key로 사용합니다.</strong></p>\n<p>그래서 오류로만 끝나는 것이죠.</p>\n<p>다음은 잘못된 key의 사용법입니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function ListItem(props) {\n  const value = props.value;\n  return (\n    // 틀렸습니다! 여기에는 key를 지정할 필요가 없습니다.\n    &lt;li key={value.toString()}&gt;{value}&lt;/li&gt;\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt; (\n    // 틀렸습니다! 여기에 key를 지정해야 합니다.\n    &lt;ListItem value={number} /&gt;\n  ));\n  return &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById(&quot;root&quot;)\n);</code>\n        </deckgo-highlight-code>\n<p>다음은 key의 옳은 사용법입니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function ListItem(props) {\n  // 맞습니다! 여기에는 key를 지정할 필요가 없습니다.\n  return &lt;li&gt;{props.value}&lt;/li&gt;;\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =&gt; (\n    // 맞습니다! 배열 안에 key를 지정해야 합니다.\n    &lt;ListItem key={number.toString()} value={number} /&gt;\n  ));\n  return &lt;ul&gt;{listItems}&lt;/ul&gt;;\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById(&quot;root&quot;)\n);</code>\n        </deckgo-highlight-code>\n<p>감이 잡히시나요?</p>\n<h1>Key는 형제 사이에서만 고유한 값이어야 한다.</h1>\n<p>이 부분은 코드를 보면 이해가 가실겁니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function Blog(props) {\n  const sidebar = (\n    &lt;ul&gt;\n      {props.posts.map((post) =&gt; (\n        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n  const content = props.posts.map((post) =&gt; (\n    &lt;div key={post.id}&gt;\n      &lt;h3&gt;{post.title}&lt;/h3&gt;\n      &lt;p&gt;{post.content}&lt;/p&gt;\n    &lt;/div&gt;\n  ));\n  return (\n    &lt;div&gt;\n      {sidebar}\n      &lt;hr /&gt;\n      {content}\n    &lt;/div&gt;\n  );\n}\n\nconst posts = [\n  { id: 1, title: &quot;Hello World&quot;, content: &quot;Welcome to learning React!&quot; },\n  { id: 2, title: &quot;Installation&quot;, content: &quot;You can install React from npm.&quot; },\n];\nReactDOM.render(&lt;Blog posts={posts} /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>post.id가 두번 사용되었는데 잘 실행됩니다.</p>\n<p>즉 여기서 알 수 있는 사실은,</p>\n<p><strong>Key는 배열 안에서 형제 사이에서 고유해야 하고 전체 범위에서 고유할 필요는 없습니다. 두 개의 다른 배열을 만들 때 동일한 key를 사용할 수 있습니다.</strong></p>\n<p>React에서 key는 힌트를 제공하지만 컴포넌트로 전달하지는 않습니다.</p>\n<p>즉, 컴포넌트에서 key에 접근할 수 없다는 것이지요.</p>\n<p>만약 다음과 같이 속성을 전달했다고 해봅시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const content = posts.map((post) =&gt; (\n  &lt;Post key={post.id} id={post.id} title={post.title} /&gt;\n));</code>\n        </deckgo-highlight-code>\n<p>그 다음 컴포넌트에서 props.key를 접근할려고 하면 읽을 수 없습니다.</p>\n<p><strong>이제 어느정도 key개념이 이해가 가시나요?</strong></p>\n<h1>💬 폼</h1>\n<p>최소한 여러분들이 HTML에서 form태그를 사용해봤다면\n다음코드를 이해하실 수 있을겁니다.</p>\n<deckgo-highlight-code html  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;form&gt;\n  &lt;label&gt;\n    Name:\n    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;\n  &lt;/label&gt;\n  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\n&lt;/form&gt;</code>\n        </deckgo-highlight-code>\n<p><strong>이 폼은 사용자가 폼을 제출하면 새로운 페이지로 이동하는 기본 HTML 폼 동작을 수행합니다.</strong></p>\n<p>React에서 동일한 동작을 원한다면 그대로 사용하면 됩니다. 그러나 대부분의 경우, JavaScript 함수로 폼의 제출을 처리하고 사용자가 폼에 입력한 데이터에 접근하도록 하는 것이 편리합니다</p>\n<p>이를 위한 표준 방식은 “제어 컴포넌트 (controlled components)“라고 불리는 기술을 이용하는 것입니다.</p>\n<h2>제어 컴포넌트 (Controlled Component)</h2>\n<p>HTML에서 <code>&#x3C;input></code>, <code>&#x3C;textarea></code>, <code>&#x3C;select></code>와 같은 폼 엘리먼트는 일반적으로 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트합니다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트됩니다.</p>\n<p><strong>React에 의해 값이 제어되는 입력 폼 엘리먼트를 “제어 컴포넌트 (controlled component)“라고 합니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: &quot;&quot; };\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({ value: event.target.value });\n  }\n\n  handleSubmit(event) {\n    alert(&quot;A name was submitted: &quot; + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          Name:\n          &lt;input\n            type=&quot;text&quot;\n            value={this.state.value}\n            onChange={this.handleChange}\n          /&gt;\n        &lt;/label&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>value 어트리뷰트는 폼 엘리먼트에 설정되므로 표시되는 값은 항상 this.state.value가 되고 React state는 신뢰 가능한 단일 출처 (single source of truth)가 됩니다. React state를 업데이트하기 위해 모든 키 입력에서 handleChange가 동작하기 때문에 사용자가 입력할 때 보여지는 값이 업데이트됩니다.</p>\n<p>제어 컴포넌트로 사용하면, input의 값은 항상 React state에 의해 결정됩니다. 코드를 조금 더 작성해야 한다는 의미이지만, <strong>다른 UI 엘리먼트에 input의 값을 전달하거나 다른 이벤트 핸들러에서 값을 재설정할 수 있습니다.</strong></p>\n<h2>textarea 태그</h2>\n<p>HTML에서 <code>&#x3C;textarea></code> 엘리먼트는 텍스트를 자식으로 정의합니다.</p>\n<p>React에서 <code>&#x3C;textarea></code>는 value 어트리뷰트를 대신 사용합니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;textarea value={this.state.value} onChange={this.handleChange} /&gt;</code>\n        </deckgo-highlight-code>\n<p>이런식으로 사용합니다.</p>\n<h2>select 태그</h2>\n<p>HTML에서 <code>&#x3C;select></code>는 드롭 다운 목록을 만듭니다. 예를 들어, 이 HTML은 과일 드롭 다운 목록을 만듭니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;select&gt;\n  &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;\n  &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;\n  &lt;option selected value=&quot;coconut&quot;&gt;\n    Coconut\n  &lt;/option&gt;\n  &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;\n&lt;/select&gt;</code>\n        </deckgo-highlight-code>\n<p>selected 옵션이 있으므로 Coconut 옵션이 초기값이 되는 점을 주의해주세요.</p>\n<p>React에서는 selected 어트리뷰트를 사용하는 대신 <strong>최상단 select태그에 value 어트리뷰트를 사용합니다.</strong> 한 곳에서 업데이트만 하면되기 때문에 제어 컴포넌트에서 사용하기 더 편합니다. 아래는 예시입니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class FlavorForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: &quot;coconut&quot; };\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({ value: event.target.value });\n  }\n\n  handleSubmit(event) {\n    alert(&quot;Your favorite flavor is: &quot; + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          Pick your favorite flavor:\n          &lt;select value={this.state.value} onChange={this.handleChange}&gt;\n            &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;\n            &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;\n            &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;\n            &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;\n          &lt;/select&gt;\n        &lt;/label&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>전반적으로 &#x3C;input type=\"text\">, &#x3C;textarea> 및 &#x3C;select> 모두 매우 비슷하게 동작합니다. 모두 제어 컴포넌트를 구현하는데 value 어트리뷰트를 허용합니다.</code></p>\n<p><img src=\"https://user-images.githubusercontent.com/48292190/116849907-9a2a4f00-ac2a-11eb-8719-49bef877e570.png\" alt=\"image\"></p>\n<h1>file input 태그</h1>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;input type=&quot;file&quot; /&gt;</code>\n        </deckgo-highlight-code>\n<p>값이 읽기 전용이기 때문에 React에서는 비제어 컴포넌트입니다.</p>\n<h1>다중 입력 제어하기</h1>\n<p>여러 input 엘리먼트를 제어해야할 때, 각 엘리먼트에 name 어트리뷰트를 추가하고 event.target.name 값을 통해 핸들러가 어떤 작업을 할 지 선택할 수 있게 해줍니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class Reservation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isGoing: true,\n      numberOfGuests: 2,\n    };\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n  }\n\n  handleInputChange(event) {\n    const target = event.target;\n    const value = target.type === &quot;checkbox&quot; ? target.checked : target.value;\n    const name = target.name;\n\n    this.setState({\n      [name]: value,\n    });\n  }\n\n  render() {\n    return (\n      &lt;form&gt;\n        &lt;label&gt;\n          Is going:\n          &lt;input\n            name=&quot;isGoing&quot;\n            type=&quot;checkbox&quot;\n            checked={this.state.isGoing}\n            onChange={this.handleInputChange}\n          /&gt;\n        &lt;/label&gt;\n        &lt;br /&gt;\n        &lt;label&gt;\n          Number of guests:\n          &lt;input\n            name=&quot;numberOfGuests&quot;\n            type=&quot;number&quot;\n            value={this.state.numberOfGuests}\n            onChange={this.handleInputChange}\n          /&gt;\n        &lt;/label&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>computed property name</code>를 사용해서 더욱 간단하게 state를 업데이트를 할 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">this.setState({\n  [name]: value,\n});</code>\n        </deckgo-highlight-code>\n<p>computed property name를 사용하지 않는다면 코드의 양이 길어질 겁니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">var partialState = {};\npartialState[name] = value;\nthis.setState(partialState);</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>setState()는 자동적으로 현재 state에 일부 state를 병합하기 때문에 바뀐 부분에 대해서만 호출하면 됩니다.</p>\n</blockquote>\n<h1>제어되는 Input Null 값</h1>\n<p>value prop을 지정하면 의도하지 않는 한 사용자가 변경할 수 없습니다. value를 설정했는데 여전히 수정할 수 있다면 실수로 value를 undefined나 null로 설정했을 수 있습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">ReactDOM.render(&lt;input value=&quot;hi&quot; /&gt;, mountNode);\n\nsetTimeout(function () {\n  ReactDOM.render(&lt;input value={null} /&gt;, mountNode);\n}, 1000);</code>\n        </deckgo-highlight-code>\n<p><strong>위 코드는 첫 번째 입력은 잠겨있지만 1초 후 입력이 가능해집니다.</strong></p>\n<h1>State 끌어올리기</h1>\n<p><img src=\"https://user-images.githubusercontent.com/48292190/116857141-4bcf7d00-ac37-11eb-8ab4-4b753b17af9c.png\" alt=\"image\"></p>\n<blockquote>\n<p>⚠️ 이 파트는 어려운 여정이 될수도 있습니다. 정신 바짝차리고 따라오세요.</p>\n</blockquote>\n<p><strong>이번 섹션에서는 주어진 온도에서 물의 끓는 여부를 추정하는 온도 계산기를 만들어볼 것입니다.</strong></p>\n<p>먼저 <code>BoilingVerdict</code>이라는 컴포넌트부터 만들어봅시다.</p>\n<p><strong>이 컴포넌트는 섭씨온도를 의미하는 celsius prop를 받아서 이 온도가 물이 끓기에 충분한지 여부를 출력합니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function BoilingVerdict(props) {\n  if (props.celsius &gt;= 100) {\n    return &lt;p&gt;The water would boil.&lt;/p&gt;;\n  }\n  return &lt;p&gt;The water would not boil.&lt;/p&gt;;\n}</code>\n        </deckgo-highlight-code>\n<p>그 다음 <code>Calculator</code>라는 컴포넌트도 하나 만들어보도록 하겠습니다.</p>\n<p><strong>이 컴포넌트는 온도를 입력할 수 있는 <code>&#x3C;input></code>을 렌더링하고 그 값을 this.state.temperature에 저장합니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">class Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = { temperature: &quot;&quot; };\n  }\n\n  handleChange(e) {\n    this.setState({ temperature: e.target.value });\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;\n        &lt;input value={temperature} onChange={this.handleChange} /&gt;\n        &lt;BoilingVerdict celsius={parseFloat(temperature)} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이제 렌더링된 화면을 보도록 하겠습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/48292190/116857877-7a9a2300-ac38-11eb-827a-5e9fcd473273.png\" alt=\"image\"></p>\n<p><em>100도가 넘어가면 자동으로 렌더링 되는 모습을 볼 수 있죠?</em></p>\n<h1>두 번째 Input 추가하기</h1>\n<p>이제 화씨 입력칸도 만들어야하기 때문에 Calculator에서 TemperatureInput라는 컴포넌트를 만들어서 위로 올리는 작업을 해주어야 합니다.</p>\n<p>다음과 같이 TemperatureInput에 로직들을 올려주고, Calculator에서 두개의 TemperatureInput을 랜더링 시켜줍시다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const scaleNames = {\n  c: &quot;Celsius&quot;,\n  f: &quot;Fahrenheit&quot;,\n};\n\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = { temperature: &quot;&quot; };\n  }\n\n  handleChange(e) {\n    this.setState({ temperature: e.target.value });\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    const scale = this.props.scale;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;\n        &lt;input value={temperature} onChange={this.handleChange} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}\n\nfunction BoilingVerdict(props) {\n  if (props.celsius &gt;= 100) {\n    return &lt;p&gt;The water would boil.&lt;/p&gt;;\n  }\n  return &lt;p&gt;The water would not boil.&lt;/p&gt;;\n}\n\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = { temperature: &quot;&quot; };\n  }\n\n  handleChange(e) {\n    this.setState({ temperature: e.target.value });\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    return (\n      &lt;div&gt;\n        &lt;TemperatureInput scale=&quot;c&quot; /&gt;\n        &lt;TemperatureInput scale=&quot;f&quot; /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;Calculator /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>그러면 화면에 input 컴포넌트가 2개가 나올겁니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/48292190/116858378-3bb89d00-ac39-11eb-8e66-b23f42869d52.png\" alt=\"image\"></p>\n<p>둘 중 하나에 온도를 입력하더라도 다른 하나는 갱신되지 않는 문제가 있습니다.</p>\n<p>이제 하나하나 개발해봅시다.</p>\n<h1>변환 함수 작성하기</h1>\n<p>섭씨를 화씨로, 또는 그 반대로 변환해주는 함수를 작성해보겠습니다.</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function toCelsius(fahrenheit) {\n  return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9) / 5 + 32;\n}</code>\n        </deckgo-highlight-code>\n<p>다음은 공식입니다.</p>\n<p>두 함수는 공식을 반환합니다.</p>\n<p>이제 temperature 문자열과 변환 함수를 인수로 취해서 문자열을 반환하는 또 다른 함수를 작성해보겠습니다</p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">function tryConvert(temperature, convert) {\n  const input = parseFloat(temperature);\n  if (Number.isNaN(input)) {\n    return &quot;&quot;;\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>예를 들어 tryConvert('abc', toCelsius)는 빈 문자열을 반환하고 tryConvert('10.22', toFahrenheit)는 '50.396'을 반환합니다.</p>\n</blockquote>\n<h1>State 끌어올리기</h1>\n<p>우리는 두 입력값이 서로의 것과 동기화된 상태로 있길 원합니다. 섭씨온도 입력값을 변경할 경우 화씨온도 입력값 역시 변환된 온도를 반영할 수 있어야 하며, 그 반대의 경우에도 마찬가지여야 합니다.</p>\n<p><strong>React에서 state를 공유하는 일은 그 값을 필요로 하는 컴포넌트 간의 가장 가까운 공통 조상으로 state를 끌어올림으로써 이뤄낼 수 있습니다.</strong></p>\n<deckgo-highlight-code js  terminal=\"carbon\" theme=\"panda\"  highlight-lines=\"\">\n          <code slot=\"code\">const scaleNames = {\n  c: &quot;Celsius&quot;,\n  f: &quot;Fahrenheit&quot;,\n};\n\nfunction toCelsius(fahrenheit) {\n  return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9) / 5 + 32;\n}\n\nfunction tryConvert(temperature, convert) {\n  const input = parseFloat(temperature);\n  if (Number.isNaN(input)) {\n    return &quot;&quot;;\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}\n\nfunction BoilingVerdict(props) {\n  if (props.celsius &gt;= 100) {\n    return &lt;p&gt;The water would boil.&lt;/p&gt;;\n  }\n  return &lt;p&gt;The water would not boil.&lt;/p&gt;;\n}\n\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onTemperatureChange(e.target.value);\n  }\n\n  render() {\n    const temperature = this.props.temperature;\n    const scale = this.props.scale;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;\n        &lt;input value={temperature} onChange={this.handleChange} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}\n\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = { temperature: &quot;&quot;, scale: &quot;c&quot; };\n  }\n\n  handleCelsiusChange(temperature) {\n    this.setState({ scale: &quot;c&quot;, temperature });\n  }\n\n  handleFahrenheitChange(temperature) {\n    this.setState({ scale: &quot;f&quot;, temperature });\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const temperature = this.state.temperature;\n    const celsius =\n      scale === &quot;f&quot; ? tryConvert(temperature, toCelsius) : temperature;\n    const fahrenheit =\n      scale === &quot;c&quot; ? tryConvert(temperature, toFahrenheit) : temperature;\n\n    return (\n      &lt;div&gt;\n        &lt;TemperatureInput\n          scale=&quot;c&quot;\n          temperature={celsius}\n          onTemperatureChange={this.handleCelsiusChange}\n        /&gt;\n        &lt;TemperatureInput\n          scale=&quot;f&quot;\n          temperature={fahrenheit}\n          onTemperatureChange={this.handleFahrenheitChange}\n        /&gt;\n        &lt;BoilingVerdict celsius={parseFloat(celsius)} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;Calculator /&gt;, document.getElementById(&quot;root&quot;));</code>\n        </deckgo-highlight-code>\n<p>완성된 최종 코드입니다.</p>\n<p>이제 대충 리액트에 대한 전반적인 느낌은 가지고 계시겠죠?</p>\n<p>이제 여러분들이 해야할 것은</p>\n<h1>리액트로 사고하기 입니다.</h1>\n<p><a href=\"https://ko.reactjs.org/docs/thinking-in-react.html\">이 링크</a>로 가셔서 리액트로 사고하는 방법을 좀 더 연구해보세요!</p>\n<h1>수고하셨습니다!</h1>\n<p><img src=\"https://i.pinimg.com/originals/a1/7c/c1/a17cc10c65943d6b1f319b72aa4aa1d5.gif\" alt=\"image\"></p>\n<p>이제 여러분은 간단한 리액트 개념에 대해서 알아보았습니다!</p>","frontmatter":{"title":"👨‍🎤 리액트, 박살내버리기.","profile":"https://avatars.githubusercontent.com/u/48292190?v=4","name":"홍준혁","createdAt":"2021년 5월 3일"}}},"pageContext":{"slug":"/blog/react_standard/"}},"staticQueryHashes":[]}